\
#!/usr/bin/env bash
set -euo pipefail

# ---------- Configurable Repo Source ----------
# You can set REPO_RAW to your GitHub raw base, e.g.:
#   export REPO_RAW="https://raw.githubusercontent.com/<org>/<repo>/main"
# Or pass --repo "https://raw.githubusercontent.com/<org>/<repo>/main"
REPO_RAW_DEFAULT="https://raw.githubusercontent.com/hamedp6/kuma-failover-installer/main"
REPO_RAW="${REPO_RAW:-$REPO_RAW_DEFAULT}"

APP_NAME="failover"
APP_USER="failover"
APP_DIR="/opt/${APP_NAME}"
PYFILE="uptime-kuma-cloudflare-failover.py"
ENV_FILE="${APP_DIR}/.env"
VENV_DIR="${APP_DIR}/venv"
SERVICE_FILE="/etc/systemd/system/${APP_NAME}.service"
PORT_DEFAULT=5000
TTL_DEFAULT=60
LOG_FILE="${APP_DIR}/failover.log"
STATE_FILE="${APP_DIR}/failover-state.json"

red()  { printf "\033[31m%s\033[0m\n" "$*"; }
grn()  { printf "\033[32m%s\033[0m\n" "$*"; }
ylw()  { printf "\033[33m%s\033[0m\n" "$*"; }
blu()  { printf "\033[34m%s\033[0m\n" "$*"; }

need_root() {
  if [[ $EUID -ne 0 ]]; then
    red "Please run as root (sudo)."
    exit 1
  fi
}

usage() {
  cat <<EOF
Usage: sudo ./install.sh [--uninstall] [--update] [--repo <raw_base_url>]

Without flags, performs an interactive install.

  --repo URL   Override raw base URL (default: ${REPO_RAW_DEFAULT})
  --update     Reinstall Python deps and refresh the app file from repo
  --uninstall  Stop service, remove files and user (optional)
EOF
}

prompt() {
  local var="$1" prompt_text="$2" default="${3-}"
  local value=""
  if [[ -n "${default}" ]]; then
    read -r -p "${prompt_text} [${default}]: " value || true
    value="${value:-$default}"
  else
    while [[ -z "${value}" ]]; do
      read -r -p "${prompt_text}: " value || true
    done
  fi
  printf "%s" "$value"
}

gen_secret() {
  python3 - <<'PY' 2>/dev/null || true
import secrets; print(secrets.token_urlsafe(24))
PY
}

install_packages() {
  blu "Installing OS packages…"
  apt-get update -y
  apt-get install -y python3 python3-venv python3-pip ufw curl
}

create_user() {
  if ! id -u "${APP_USER}" >/dev/null 2>&1; then
    blu "Creating system user ${APP_USER}…"
    useradd --system --create-home --home-dir "${APP_DIR}" --shell /usr/sbin/nologin "${APP_USER}"
  fi
}

setup_dirs() {
  blu "Creating ${APP_DIR}…"
  mkdir -p "${APP_DIR}"
  touch "${LOG_FILE}" "${STATE_FILE}"
  chown -R "${APP_USER}:${APP_USER}" "${APP_DIR}"
}

create_venv() {
  blu "Creating Python venv…"
  python3 -m venv "${VENV_DIR}"
  "${VENV_DIR}/bin/pip" install --upgrade pip
  "${VENV_DIR}/bin/pip" install flask requests python-dotenv
}

download_app() {
  blu "Fetching ${PYFILE} from ${REPO_RAW}…"
  if ! curl -fsSL "${REPO_RAW}/${PYFILE}" -o "${APP_DIR}/${PYFILE}"; then
    red "Failed to download ${PYFILE} from ${REPO_RAW}"
    red "Set REPO_RAW or run with --repo https://raw.githubusercontent.com/<org>/<repo>/main"
    exit 1
  fi
  chown "${APP_USER}:${APP_USER}" "${APP_DIR}/${PYFILE}"
}

write_env() {
  blu "Configuring environment (.env)…"

  CF_ZONE_ID=$(prompt CF_ZONE_ID "Cloudflare Zone ID" "")
  CF_API_TOKEN=$(prompt CF_API_TOKEN "Cloudflare API Token (DNS edit scope)" "")
  DNS_RECORDS=$(prompt DNS_RECORDS "Comma-separated FQDNs (e.g. api.example.com,www.example.com)" "")
  SERVER1_IP=$(prompt SERVER1_IP "Server 1 IP" "")
  SERVER2_IP=$(prompt SERVER2_IP "Server 2 IP" "")
  PORT=$(prompt PORT "HTTP Port" "${PORT_DEFAULT}")
  TTL=$(prompt TTL "DNS TTL (min 30)" "${TTL_DEFAULT}")
  ADMIN_USER_IN=$(prompt ADMIN_USER "Admin username for UI (leave empty to disable auth)" "")
  ADMIN_PASS_IN=""
  if [[ -n "${ADMIN_USER_IN}" ]]; then
    ADMIN_PASS_IN=$(prompt ADMIN_PASS "Admin password for UI" "")
  fi
  TG_BOT=$(prompt TELEGRAM_BOT_TOKEN "Telegram Bot Token (optional)" "")
  TG_CHAT=$(prompt TELEGRAM_CHAT_ID "Telegram Chat ID (optional)" "")

  SECRET_KEY=$(gen_secret)
  [[ -z "${SECRET_KEY}" ]] && SECRET_KEY="$(head -c 16 /dev/urandom | xxd -p)"

  cat > "${ENV_FILE}" <<EOF
# Generated by install.sh – edit as needed
CLOUDFLARE_ZONE_ID=${CF_ZONE_ID}
CLOUDFLARE_API_TOKEN=${CF_API_TOKEN}
DNS_RECORD_NAMES=${DNS_RECORDS}
SERVER1_IP=${SERVER1_IP}
SERVER2_IP=${SERVER2_IP}
PORT=${PORT}
TTL=${TTL}
LOG_FILE=${LOG_FILE}
STATE_FILE=${STATE_FILE}
SECRET_KEY=${SECRET_KEY}
ADMIN_USER=${ADMIN_USER_IN}
ADMIN_PASS=${ADMIN_PASS_IN}
TELEGRAM_BOT_TOKEN=${TG_BOT}
TELEGRAM_CHAT_ID=${TG_CHAT}
EOF

  chown "${APP_USER}:${APP_USER}" "${ENV_FILE}"
  chmod 600 "${ENV_FILE}"
}


preseed_secret() {
  blu "Pre-seeding webhook secret…"
  read -r -p "Webhook secret (leave empty to auto-generate): " WH_SECRET || true
  if [[ -z "${WH_SECRET}" ]]; then
    WH_SECRET="$(gen_secret)"
    [[ -z "${WH_SECRET}" ]] && WH_SECRET="$(head -c 24 /dev/urandom | base64 -w0)"
    ylw "Generated secret."
  fi
  # write minimal JSON with secret; keep any existing file content if already present
  if [[ -s "${STATE_FILE}" ]]; then
    # Try to update existing JSON in-place (best effort)
    if command -v jq >/dev/null 2>&1; then
      tmp="$(mktemp)"
      jq --arg s "${WH_SECRET}" '.webhook_secret=$s' "${STATE_FILE}" > "$tmp" 2>/dev/null || echo "{\"webhook_secret\":\"${WH_SECRET}\"}" > "$tmp"
      mv "$tmp" "${STATE_FILE}"
    else
      echo "{\"webhook_secret\":\"${WH_SECRET}\"}" > "${STATE_FILE}"
    fi
  else
    echo "{\"webhook_secret\":\"${WH_SECRET}\"}" > "${STATE_FILE}"
  fi
  chown "${APP_USER}:${APP_USER}" "${STATE_FILE}"
  chmod 600 "${STATE_FILE}"
}
write_service() {
  blu "Writing systemd unit…"
  cat > "${SERVICE_FILE}" <<EOF
[Unit]
Description=Uptime Kuma → Cloudflare Failover (Flask UI)
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=${APP_USER}
Group=${APP_USER}
WorkingDirectory=${APP_DIR}
Environment=PYTHONUNBUFFERED=1
ExecStart=${VENV_DIR}/bin/python ${APP_DIR}/${PYFILE}
Restart=on-failure
RestartSec=3
# Hardening
NoNewPrivileges=true
PrivateTmp=true
ProtectHome=true
ProtectSystem=full
ReadWritePaths=${APP_DIR}
AmbientCapabilities=
CapabilityBoundingSet=

[Install]
WantedBy=multi-user.target
EOF
  systemctl daemon-reload
}

enable_firewall() {
  read -r -p "Open port ${PORT} with UFW? [y/N]: " openufw || true
  if [[ "${openufw,,}" == "y" ]]; then
    ufw allow "${PORT}"/tcp || true
    ylw "If UFW is inactive, enable it carefully: sudo ufw enable"
  fi
}

start_service() {
  blu "Starting service…"
  systemctl enable "${APP_NAME}" --now
  systemctl status --no-pager "${APP_NAME}" || true
}

uninstall() {
  need_root
  ylw "Uninstalling ${APP_NAME}…"
  systemctl disable --now "${APP_NAME}" || true
  rm -f "${SERVICE_FILE}"
  systemctl daemon-reload
  read -r -p "Remove ${APP_DIR}? This deletes logs/state. [y/N]: " del || true
  if [[ "${del,,}" == "y" ]]; then
    rm -rf "${APP_DIR}"
    userdel -r "${APP_USER}" 2>/dev/null || true
  fi
  grn "Uninstalled."
  exit 0
}

update() {
  need_root
  blu "Updating app & deps…"
  download_app
  "${VENV_DIR}/bin/pip" install --upgrade flask requests python-dotenv
  systemctl restart "${APP_NAME}"
  grn "Updated and restarted."
  exit 0
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --uninstall) ACTION="uninstall"; shift ;;
      --update)    ACTION="update"; shift ;;
      --repo)      REPO_RAW="$2"; shift 2 ;;
      -h|--help)   usage; exit 0 ;;
      *) red "Unknown arg: $1"; usage; exit 1 ;;
    esac
  done
}

main() {
  ACTION="install"
  parse_args "$@"

  if [[ "${ACTION}" == "uninstall" ]]; then uninstall; fi
  if [[ "${ACTION}" == "update" ]]; then update; fi

  need_root
  install_packages
  create_user
  setup_dirs
  create_venv
  download_app
  write_env
  preseed_secret
  write_service
  enable_firewall
  start_service

  grn "Done."
  echo
  ylw "Open: http://<this-server-ip>:${PORT_DEFAULT}/"
  echo "Basic Auth: $( [[ -n "${ADMIN_USER_IN-}" ]] and echo "${ADMIN_USER_IN}" || echo 'disabled')"
  echo
  cat <<TIPS
Next steps:
  1) In Uptime Kuma, add header to both webhooks:
       X-Webhook-Secret: <from ${STATE_FILE} after first run, or rotate in UI Settings>
  2) To view logs live: journalctl -u ${APP_NAME} -f
  3) To rotate the webhook secret: open UI → Settings → Rotate Secret.
  4) To update later: sudo ./install.sh --repo "${REPO_RAW}" --update
TIPS
}

main "$@"
